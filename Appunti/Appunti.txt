----------------------- Lezione 2 - 27/09/2023 (la prima era solo introduzione) -----------------------

Software: programma sviluppato per risolvere determinate esigenze. Comprende anche la documentazione associata.
- Generico: sviluppato per risolvere problemi per utenti differenti.
- Custom: sviluppato per un determinati utenti.

Ingegneria del software: disciplina che tocca tutti gli aspetti per la creazione di un software.
Ingegneria dei sistemi: disciplina che tocca gli aspetti legati al circuito.

Modello di processo di sviluppo software: rappresentazione semplificata dello sviluppo software.

// Costi dello sviluppo di un software: 60% costi di sviluppo, 40% testing. Inoltre i costi variano in base al sistema
// che vogliamo sviluppare, performance e affidabilità <- (molto importante). La distribuzione dei costi dipende dal modello che si usa.

- Modello a cascata: 25% specification, 25% design, 25% sviluppo, 50% integrazione e testing
- Modello iterativo: 50% sviluppo iterativo, 25% testing , 25% specification
- Modello component-based: 25% sviluppo , 50% testing, 25% specification

CASE (Computer-Aided Software Engineering) -> Software che servono a creare software. Esistono due tipo:
- Upper CASE: supportano la gestione del software "all'inizio", quindi design e requisiti per la sua creazione.
- Lower CASE: supportano la gestione del software "alla fine", quindi debbugging, test e programmazione.

Un software deve essere:
- Affidabile: il sistema deve essere affidabile.
- Efficiente: il software non deve sprecare risorse.
- Mantenibile: il software deve essere aggiornato con le nuove tecnologie.
- Accettabile: il software deve essere accettato dagli utenti finali per cui è designato. Quindi deve essere usabile e compatibile con altri sistemi.

Sfide da affrontare come Ingegnere del software:
- Eterogenità: svillupare un software che può collaborare con diverse piattaforme
- Sviluppare tecniche per una consegna veloce del software
- Sviluppare un software che può essere considerato affidabile dagli utenti finali

Processi software: una serie di attività per lo sviluppo dal software.
- Specification
- Design
- Validation
- Evolution

Esempi di software process model:
- Waterfall model: Modello che separa le fasi di specification e sviluppo. Qui il cliente è presente solo nella fase di analisi. Il problema principale di questo 
modello è la flessibilità perchè non si può tornare indietro e modificare quando si vuole (proprio per questo si chiama a cascata). Le fasi sono:
    1) Analisi e definizione dei requisiti
    2) Design del software (progettazione)
    3) Implementazione e unità di test
    4) Manutenzione
- Evolutionary development (evolutivo): Specification, sviluppo e validation sono intercollegate. Ha l'obiettivo di avere un feedback costante con il cliente, quindi
evolvere il progetto in base a ciò che sceglie il cliente. Il problema principale è quella di poter perdere di vista il focus principale del progetto oppure
fare scelte iniziali che potrebbero portare problemi con aggiornamenti futuri. 
- Process iteration: i requisiti di sistema si evolvono continuamente durante la realizzazione del progetto. Qui il progetto viene spezzato incrementi che si 
ripetono fino a che il progetto non è completo. In questo processo è difficile avere una costante collaborazione col cliente dato che ad ogni iterazione 
bisogna confrontarsi col cliente per sapere come procedere.
- Spiral development: Qui si da molta attenzione ai rischi possibili che si potrebbero creare, in modo da ridurli. Ogni loop nella spirale rappresenta 
una fase del processo. Non abbiamo delle fasi specifiche, cambiano in base ai requisiti.

// Throw-away prototyping: modello usa e getta usato come presentazione per il cliente e successivamente buttato.
// Component-based software engineering: Software creato dall'unione di componenti già esistenti o sono sistemi COTS (Commercial-off-the-shelf).

Requisito: il processo in cui si stabilisce che servizi sono richiesti e i vincoli per le operazioni di sistema e sviluppo.

Requirements engineering process (output dell'analisi dei requisiti):
- Feasibilty study: studio di fattibilità
- Requirements elicitation and analysis: 
- Requirements specification: 
- Requirements validation: capire quali requisiti hanno dei conflitti

Software design and implementation: il processo di convertire il sistema "astratto" in un sistema eseguibile.

Design process activtity:
- Architectural design
- Abstract specification
- Interface design
- Component design
- Data structure design
- Algorithm design

Programmazione e debbugging: transformare il design in un programma rimuovendo gli errori.
Software evolution: si interviene per tenere il software aggiornato continuamente.
Tools: singoli strumenti
Workbench: insieme di tools
Enviroments: insieme di workbench (come un IDE)

----------------------- Lezione 3 - 03/10/2023 -----------------------

Requisito: una frase che descrive un servizio o una restrizione del sistema. I requisiti possono essere imprecisi perchè il cliente non sa cosa vuole o perchè non sa come
esprimerlo. Quindi bisogna fare attenzione e cercare di interpretare al meglio i requisiti; devono essere completi e consistenti. 
I requisiti sono completi se non manca nessuna informazione importante e sono consistenti se non ci sono conflitti tra i requisiti. 
(In pratica però è difficile avere requisiti completi e consistenti). I requisiti sono classificati in:
- high-level: descrivono le funzionalità del sistema e le sue restrizioni usando un linguaggio qualsiasi (in modo astratto).
- low-level: descrivono i requisiti del sistema in modo dettagliato, avvicinandosi molti ai dettagli implementativi.

Requisiti utente: requisiti che descrivono le funzionalità del sistema dal punto di vista dell'utente. Può essere rappresentati in 2 modi:
- In un linguaggio naturale o con diagrammi dei servizi di sistema e vincoli.
- Scritto per gli utenti finali e per gli sviluppatori.

Requisiti di sistema: descrivono le funzionalità dal punto di vista del sistema. Un documento strutturato che contiene in modo dettagliato i requisiti del sistema, 
servizi di sistema e vincoli. Si usa un linguaggio formale per descrivere i requisiti.

Requisiti funzionali: descrivono le funzionalità del sistema, i servizi che il sistema deve fornire e come deve reagire a determinate situazioni.
- Ad esempio: "Il sistema deve permettere agli utenti di creare un account". 
Requisiti non funzionali: descrivono i vincoli sul sistema o sui suoi componenti. Possono essere vincoli di processo, vincoli di interfaccia, vincoli di progettazione.
- Ad esempio: "Il sistema deve essere disponibile 24/7 e deve sostenere 1mln di utenti connessi contemporaneamente".
Requisiti del dominio: requisiti che derivano dal dominio di applicazione del sistema e che riflettono le caratteristiche del dominio stesso.
- Ad esempio: "Il sistema deve essere in grado di gestire i dati dei pazienti". Quindi qualcosa che serve per il corretto funzionamento del dominio.

LIBSYS: sistema per la gestione di una biblioteca.
- Il sistema deve permettere agli utenti di cercare i libri, prenotarli e ritirarli.
- Ogni ordine deve essere registrato e identifica tramite un codice univoco.

Obiettivo: è un requisito che deve essere soddisfatto dal sistema.
Differenza fra obiettivo e requisito: un obiettivo è qualcosa che il sistema deve fare, un requisito è qualcosa che il sistema deve essere.

Caratteristiche dei requisiti:
- Validità
- Completezza
- Realismo
- Verificabilità

/* Questi appunti sono Universitari. Vorrei fossi più preciso possibile. Se trovi errori, scrivimi su Telegram @DavideC03. Chi è @DavideC03? Sono io, Davide Cappellino, 
uno studente di Ingegneria Informatica all'Università di Pisa. LOL */

Diagramma della sequenza: diagramma che mostra le interazioni tra oggetti in un sistema. Mostra gli oggetti e i messaggi che si scambiano.

Requirements engineering process -> attività da fare:
- requisito di validazione
- requisito di analisi
- requisito di gestione
- requisito di identificazione

Identificazione e analisi: coinvolge gli utenti finali e gli stakeholder per capire cosa vogliono dal sistema. Più stakeholders sono coinvolti, più è difficile
avere un accordo su cosa fare.

Problemi dell'analisi dei requisiti:
- Problemi di comprensione: gli stakeholders non sanno cosa vogliono o non sanno come esprimerlo.
- Problemi di ambiguità: gli stakeholders esprimono i requisti in modo ambiguo.
- Problemi di conflitto: gli stakeholders hanno esigenze diverse e quindi i requisiti possono essere in conflitto.
- Problemi di cambiamento: i requisiti cambiano nel tempo.
- Problemi di organizzazione: l'organizzazione può influenzare la definizione dei requisiti.
Come limitare i problemi dell'analisi dei requisiti:
- Punto di vista: un modo di strutturare i requisiti in base al tipo di stakeholder che li esprime.
- Analisi multi-prospettiva: un modo per analizzare i requisiti da più punti di vista ed è fondamentale per un corretto sviluppo e funzionamento del software.
- Interviste: sono un modo diretto per capire cosa vogliono gli stakeholders. 
- Scopo dell'etnografia: requisiti che derivano dall'osservazione di come lavorano gli stakeholders.
- Scenario: un esempio reale di come il sistema verrà usato. Gli scenari sono utili per capire cosa vogliono gli stakeholders e per capire se i requisiti 
  sono completi e consistenti.
  Devono includere:
    - Una descrizione della situazione iniziale
    - Una descrizione del normale flusso di eventi
    - Una descrizione di cosa può andare storto
    - Informazioni sulle altre attività che si svolgono in parallelo
    - Una descrizione della situazione finale

----------------------- Lezione 4 - 04/10/2023 -----------------------

System modelling: aiuta l'analisi dei requisiti e la loro comprensione. Esistomo modelli differenti in base alla prospettiva che si vuole analizzare:
- prospettiva esterna che mostra il contesto del sistema e dell'ambiente
- prospettiva comportamentale che mostra il comportamento del sistema
- prospettiva strutturale che mostra la struttura del sistema o l'architettura dei dati

Data flow diagrams (diagramma di flusso): è un modello che serve per rappresentare il processamento dei dati. I dati sono rappresentati come flussi di dati.

Dizionario dei dati (glossario): è un documento che contiene la definizione di tutti i termini usati nel sistema.
Vantaggi: aiuta a capire cosa vuole il cliente e aiuta a capire se i requisiti sono completi e consistenti, inoltre aiuta a capire se i requisiti sono 
comprensibili e se sono ambigui.
Svantaggi: è difficile da mantenere e può essere difficile da capire.

Modelli ad oggetti(object models): descrivono il sistema in termini di oggetti e delle loro interazioni. Gli oggetti sono rappresentati come classi e
le interazioni sono rappresentate come messaggi.

// Un oggetto è un'astrazione di un entità del mondo reale che ha uno stato e un comportamento. Un oggetto ha un'identità, uno stato e un comportamento.
// UML: è uno standard di rappresentazione ideato dagli sviluppatori e viene usato per rappresentare i modelli ad oggetti.

Metodi strutturati: sono modelli incorporati come parte ereditata del sistema.
Method weakness (debolezze dei metodi strutturati):
- potrebbero produrre troppa documentazione
- potrebbero essere troppo astratti
- potrebbero essere troppo dettagliati

//Specifica formale: è una specifica che usa un linguaggio formale per descrivere il sistema. I linguaggi formali sono linguaggi matematici che 
// hanno una sintassi e una semantica.

Validazione dei requisiti: è il processo di verifica dei requisiti. I costi che porta una validazione dei requisiti errata sono molto alti e 
possono portare a numerosi problemi in futuro. 
Cosa fare per effettuarla:
- Validità: il sistema fornisce funzioni per il supporto completo verso il cliente?
- Consistenza: i requisiti sono consistenti e non si contraddicono?
- Completezza: tutti i servizi richiesti dal cliente sono stati forniti?
- Realizzabilità: i requisiti possono essere implementati in base al budget e tecnologia disponibili?
- Verificabilità: è possibile verificare che il sistema soddisfi i requisiti?

Tre fasi per validare i requisiti:
- Revisione: i requisiti sono esaminati da un gruppo di persone che non hanno partecipato alla loro scrittura.
- Prototipazione: si crea un prototipo del sistema per capire se i requisiti sono completi e consistenti.
- Test: si creano dei test per capire se i requisiti sono completi e consistenti.

Metodi formali: metodi matematici per la validazione dei requisiti. Solitamente non sono molto usati.

Tecnice di specificazione (specification techniques): sono usate per rappresentare i requisiti in modo formale.

// SEGNALIBRO

----- PROGETTAZIONE SOFTWARE (Design) -----

Il processo di conversione della specificazione del sistema in un sistema eseguibile.

Design process activities (attività del processo di progettazione): 
- Architectural design: definisce la struttura del sistema. E' un modo per spezzare il sistema in sottosistemi (moduli) per semplicizzare la progettazione.
- Abstract specification: definisce le componenti del sistema in modo astratto.
- Interface design: definisce le interfacce del sistema.
- Component design: definisce le componenti del sistema.
- Data structure design: definisce le strutture dati del sistema.
- Algorithm design: definisce gli algoritmi del sistema.

Nell'architectural design si impongono dei vincoli per la progettazione che bisogna rispettare. Si usa il diagramma Box and Line, il quale è un diagramma che mostra i 
moduli e le loro interazioni. Descrivendo l'architettura del sistema si facilita la comunicazione con gli stakeholders e si facilita 
la comprensione del sistema. Le caratteristiche sono: performance, sicurezza, affidabilità, mantenibilità e portabilità.
Strategia per strutturare il sistema: repository model, Service-oriented model e macchina a strati.
Repository model: si progetta il tutto intorno alla base di dati (attualmenete è poco usata). Con una grande quantità di dati
condivisi da gestire però ancora ora è molto utilizzata.
Vantaggi:
- Modo efficiente per gestire una grande quantità di dati
- Al sotto sistema non interessa come i dati sono centralizzati e gestiti (es backup, security)
Svantaggi:
- Il cambio o evoluzione di dati è difficile e costoso da attuare
- Difficile da distribuire in modo efficiente

Modello Client-Server: è un modello che divide il sistema in due parti: client e server. Il client è l'interfaccia utente e il server è il sistema che fornisce
i servizi. Il client e il server comunicano tramite una rete. Il client e il server possono essere su macchine diverse o sulla stessa macchina. Sono indipendenti e
possono essere sviluppati in modo indipendente.
Svantaggi: 
- Alta complessità di realizzazione
- Alta complessità di gestione
- Dati rendundanti in ogni server
- Difficile capire quali server e servizi sono disponibili

Abstract machine model (modello di macchina astratta): è un modello che divide il sistema in vari parti. Ogni strato non sa cosa fanno gli altri strati ma 
ogni strato conosce quello superiore e inferiore.
Grazie a questo modello si ha una maggiore modularità e si facilita la manutenzione.

Modulo: è un componente di un sistema che ha una funzione ben definita e che può essere sviluppato in modo indipendente.

Per descrivere i software esistono due modi:
- Pipeline model: è un modello che descrive il sistema come una serie di componenti che elaborano i dati in modo sequenziale.
- Object model: è un modello dove il sistema è diviso in oggetti interattivi.

Stili di controllo: si occupano di controllare il flusso tra sottosistemi. I principali sono:
- Controllo centralizzato: un sistema ha tutte le resposanbilità e controlla tutto per la gestione ed esecuzione dei sistemi.
    1) Modello call-return: modello top-down il cui controllo inizia da un punto e si espande verso il basso. Può essere applicato ai modelli sequenziali.
    2) Modello manager: un componente controlla stopping, starting e coordinazione degli altri processi. Può essere applicato ai modelli concorrenti.
- Controllo basato sugli eventi: ogni sottosistema risponde agli eventi che riceve da altri sottosistemi, esternamente o generati dall'ambiente del sistema.
    1) Modello di trasmissione Broadcast: un sottosistema invia un messaggio a tutti gli altri sottosistemi.
    2) Modelli guidati da interruzioni: funziona tramite interruzioni (interrupt). Quando un sottosistema riceve un interruzione, il sottosistema interrompe quello 
       che sta facendo e si occupa dell'interruzione.

----- ARCHITETTURA A SISTEMI DISTRIBUITI (Distribuited System Architecture) -----

Sistema Embedded: è un sistema che è viene usato per piccoli dispositvi elettronici. (es Arduino, Lavatrice)

Sistema distribuito: è un sistema che è composto da più componenti (nodi) che comunicano tramite una rete. (es Internet, Cloud)
Deve essere:
- Scalabile: deve essere in grado di gestire un numero variabile di utenti
- Sicuro: deve essere in grado di proteggere i dati
- Mantenibile: deve essere aggiornato con nuove tecnologie
- Fault tolerant: deve essere in grado di funzionare anche se alcuni nodi non funzionano
- Openness: deve essere in grado di comunicare con altri sistemi
- Concurrency: deve essere in grado di gestire più utenti contemporaneamente

/*  Client-Server e ad oggetti distribuiti saranno quelle trattati in questo corso
//  netstat -l -> Visualizza statistiche relative ai protocolli e alle connessioni di rete TCP/IP correnti.
//  netstat -a -> Visualizza tutte le connessioni e i porti TCP e UDP in ascolto.
//  netstat -e -> Visualizza le statistiche Ethernet, ad esempio i byte trasmessi e ricevuti.
//  netstat -n -> Visualizza gli indirizzi e i numeri di porta in formato numerico.
//  netstat -o -> Visualizza il PID (identificatore di processo) del processo proprietario per ogni connessione attiva.
//  netstat -p -> Visualizza il nome del programma che ha aperto la connessione.
//  netstat -r -> Visualizza la tabella di routing.
*/  netstat -s -> Visualizza le statistiche per i protocolli IP, ICMP, TCP e UDP.

Il client-server prevede 3 strati:
- Presentation layer: è lo strato che si occupa di presentare i dati all'utente
- Application layer: è lo strato che si occupa di gestire le richieste dell'utente
- Data Managment Layer: è lo strato che si occupa di gestire i dati

Esistono due tipo di client:
- Fat-Client Model: è un client che si occupa di gestire i dati e di presentarli all'utente. Il server si occupa solo di gestire le richieste dell'utente.
- Thin-Client Model: è un client che si occupa solo di presentare i dati all'utente. Il server si occupa di gestire i dati e di gestire le richieste dell'utente.

Architettura ad oggetti distribuiti: è un'architettura che si basa sul paradigma ad oggetti. I componenti sono oggetti che comunicano tramite messaggi.
Come standard internazionale viene usato Corba (Common Object Request Broker Architecture) oppure Peer-to-Peer (P2P). In questa architettura non c'è un server
centrale ma ogni nodo può essere sia client che server. Questo facilità la condivisione dei dati. (es Emule, Torrent)

Service-oriented architectures: è basato sulla nozione di servizio. Lo standard internazionale attuale è REST (Representational State Transfer).
Serve a creare servizi che possono essere usati da altri sistemi. (es Google Maps)


----------------------- Lezione 5 - 06/10/2023 -----------------------

// Il modello a cascata è poco pratico perchè i requisiti possono cambiare nel tempo e quindi bisogna tornare indietro e modificare il software.

----- SVILUPPO -----

Rapid Software Development (RAD, è un modello iterativo) nasce perchè a volte c'è bisogno di sviluppare un software in poco tempo. Inoltre si può avere un feeback costante con il cliente.
Inoltre nel RAD spesso viene creato un prototipo usa e getta per mostrare al cliente come sarà il software. Solitamente nel prototipo non vengono usate le 
tecnologie migliori, quindi è sconsigliato usarlo come punto di partenza.
Carratteristiche:
- Cicli di sviluppo brevi
- E' formato da vari 
- I requisiti cambiano di continuo
// SEGNALIBRO 2

Problemi legati al RAD:
- conivolgimento costante col cliente
- problemi di gestione
- problemi di manutenzione
- problemi di contratto: siccome il software viene sviluppato in poco tempo, il contratto è difficile da formulare a causa dei continui cambiamenti.

Ambienti di sviluppo RAD: gli ambienti RAD sono stati per facilitare il lavoro. Per esempio generatori di interfacce, generatori di report, database programming
language o il links to office application (ovvero app che vengono adattate in base all'azienda usata. La base del software però rimane sempre la stessa)

COTS (Commercial off the shelf): COTS sono software che sono già pronti e che possono essere usati per sviluppare un software. (es Microsoft Office)
Svantaggi:
- Non si può modificare il software
- Non si può sapere come è stato sviluppato il software, quindi non si può sapere se è affidabile e sicuro
- Il software potrebbe non essere aggiornato a lungo termine

Metodi agili: cercano di arrivare all'obiettivo in modo evolutivo-incrementale in modo da ridurre al minimo la documentazione.
Principi:
- Customer involvment: il cliente deve essere coinvolto in tutto il processo di sviluppo
- Incremental delivery: il software deve essere sviluppato in modo incrementale specificando i requisiti di ogni incremento 
- People not process: le skills del team di sviluppo devono essere riconosciute ed esplorate
- Embrance change: progettare il sistema in modo tale possa accomodare i cambiamenti
- Maintain simplicity: bisogna concentrarsi anche sul mantenere il sistema semplice

Problematiche legate ai metodi agili:
- lavorare in modo costante è difficile col metodo agile
- dare priorità ai requisiti è difficile soprattutto con multipli stakeholders
- è difficile mantenere l'interesse dei clienti che sono coinvolti nel progetto
- è difficile mantenere la qualità del software
- avere un contratto può essere un problema (è comunque un modello iterativo)
- mantenere la semplicità non è facile

Extreme Programming (metodo agile): è uno dei metodi più usati e più vecchi. E' estremo perchè:
- si devono creare continuamente nuove build per sapere se il progetto si sta sviluppando correttamente (Solitamente ogni 2 settimane ci deve essere uno sviluppo incrementale)
- si deve fare il refactoring continuamente
- si deve fare il testing continuamente (su tutte le build)

Come applicare l'Extreme programming:
- Incremental planning: i requisiti vengono raccolti in delle Story Cards (contengono i requisiti). Le Story Cards vengono divise in task e assegnate ai programmatori.
- Small releases: il software viene rilasciato in piccole parti con un minimo set di funzionalità in modo da farlo testare al cliente.
- Simple design: il design deve essere il più semplice possibile in modo da rispettare il più possibile i requisiti.
- Test first development: prima di scrivere il codice si scrivono i test per capire se il codice funziona.
- Refactoring: il codice deve essere continuamente migliorato in modo da rendere il codice semplice e aggiornabile.
- Pair programming: due programmatori lavorano insieme su un singolo computer. Uno scrive il codice e l'altro controlla che il codice sia corretto.
- Collective ownership: tutti i programmatori possono modificare il codice, quindi nessuno ha la sua area di sviluppo.
- Continuous integration: il codice viene integrato continuamente in modo da capire se il codice funziona. Anche qui devono essere eseguiti test.
- Sustainaible pace: i programmatori devono lavorare in modo costante e non devono lavorare troppo, in modo da non perdere qualità.
- On-site customer: il cliente deve essere presente durante tutto lo sviluppo del software.
- Coding standards: il codice deve essere scritto in modo standard in modo da essere comprensibile da tutti.

/*
SCRAM: è un metodo agile che si basa sullo sviluppo incrementale. I requisiti vengono raccolti in delle Story Cards (contengono i requisiti). Le Story Cards 
vengono divise in task e assegnate ai programmatori. Inoltre ogni task ha un tempo limite per essere completato.
KANVAN è simile a SCRAM ma non ha un tempo limite per completare i task.
La Story cards dice COSA fare, il task COME farlo
*/

Software reuse: è un modo per riutilizzare codice già esistente. Si possono riusare intere applicazioni, parti di applicazioni o parti di codice.
Cosa si può riusare nello specifico: codice, librerie, frameworks, COTS, Aspect-oriented software development, program generators, design patterns ecc...
Riuso concettuale: si riusa il concetto di un software e non il software in sè. (es riusare il concetto di un software di gestione di una biblioteca):
Approcci principali:
- Application frameworks: sono librerie di classi che possono essere riusate per creare un software.
- Design patterns: sono modelli di progettazione che possono essere riusati per creare un software.
- Component-based development: sistemi sviluppati attraverso l'integrazione di più componenti conformi al modello dei componenti standard.
- Legacy system wrapping: si riusa un software esistente e si aggiunge un nuovo software che si interfaccia con il software esistente.
- Service-oriented systems: sistemi sviluppati sfruttando servizi presi dall'esterno.
- Application product lines: un tipo di app che può essere adattata in differenti modo in base al cliente.
- COTS integration: sistemi sviluppati attraverso app esistenti.
- Configurable vertical application: un sistema creato in modo generico per poi essere configurato a piacimento dal cliente.
- Program generators: sono programmi che generano codice in base a dei parametri.
- Program libraries: classi e funzioni di libreria disponibili per l'utilizzo.
- Aspect-oriented development: diversi componenti intrecciati in un app in differenti posti durante la compilazione del programma. 


/* 
Aspect-oriented software development: è un modo per riusare il codice. Si divide il codice in parti e si riusa solo la parte che serve. Si aggiunge una notazione
che viene attivata quando serve.
*/

Sistemi di ERP (Enterprise Resource Planning): sono sistemi generici che possono essere usati per creare un software per le risorse aziendali (es SAP).

----- SOFTWARE EVOLUTION -----

Software evolution: è il processo di cambiamento del software nel tempo. Il software deve essere aggiornato per rispettare i requisiti e per rispettare 
le nuove tecnologie. Il software quindi cambia continuamente infatti emergono sempre nuovi requisiti, nuove tecnologie, nuovi problemi, nuovi errori ecc... 
Il cambiamento è INEVITABILE.

Program evolution dynamics: è lo studio del processo di cambiamento del software nel tempo. Lehman e Belady hanno proprosto una serie di "leggi" da rispettare:
- Legge del cambiamento continuo: il software deve essere aggiornato continuamente per rispettare i requisiti e le nuove tecnologie, altrimenti diventa obsoleto.
- Legge del complesso crescente: il software diventa sempre più complesso nel tempo. Le risorse extra devono cercare di semplificare e preservare la struttura del software.
- Legge della conservazione della familiarità: il software deve essere aggiornato in modo da non perdere la familiarità con il software.
- Legge del declino continuo: il software diventa sempre meno utile nel tempo. Il software deve essere aggiornato in modo da non diventare obsoleto.
- Legge della crescita continua: il software deve essere aggiornato in modo da soddisfare sempre il cliente e non diventare obsoleto. 
// - Large Program evolution: è un processo che si auto-regola. Gli attributi del sistema (size, tempo fra rilasci, il numero di errori) sono solitamente invarianti per rilascio.

Distribuzione dei costi di mantenimento: 65% Aggiunta di funzionlità, 25% correzione di errori, 10% adattamento a nuove piattaforme. // da rivedere

Fattori di costo di mantenimento:
- Stabilità del team: se il team cambia spesso, il costo di mantenimento aumenta.
- Staff skills: se il team non ha le competenze per mantenere il software, il costo di mantenimento aumenta.
- Responsabilità contrattuali: il team di sviluppo potrebbe non avere responsabilità contrattuali per il mantenimento e quindi non essere incentivati ad aggiornare il software.
- Program age and structure: col passare del tempo il software invecchia quindi diventa sempre più difficile da capire ed aggiornare.

Il processo di evoluzione dipende da:
- il tipo di software da mantenere
- il processo di sviluppo usato
- skills ed esperienza delle persone coinvolte

System reengineering: è il processo di riprogettazione del software in modo da rispettare i requisiti e le nuove tecnologie. Si possono sia riscrivere alcuni 
componenti, ripartire da zero (forward engineering) oppure leggere il codice per capire com'è fatto e implementarlo (reverse engineering).
Vantaggi:
- Si riducono i rischi 
- Si riducono i costi
- Si riducono i tempi

Reengineering process activities:
- Source code translation: si traduce il codice in un altro linguaggio
- Program structure improvement: si migliora la struttura del programma
- Program modularization: si divide il programma in moduli
- Data reengineering: si riscrive il codice per rispettare i nuovi requisiti
- Forward engineering: si riscrive il codice da zero
- Reverse engineering: si legge il codice per capire come è fatto e si riscrive

// Rosetta: è un software che traduce il codice da un linguaggio ad un altro (fatto da Apple).

Legacy system evolution (evoluzione dei sistemi ereditati): è il processo di evoluzione di un sistema ereditato. I sistemi ereditati sono sistemi 
che sono stati sviluppati in passato e che sono ancora usati. I sistemi ereditati sono difficili da mantenere perchè sono vecchi e non sono aggiornati.
Per evolvere un sistema ereditato si può:
- Riscrivere il sistema da zero
- Continuare ad evolverlo
- Sostituire il sistema con un sistema nuovo
- Reingegniarizzare il sistema

Categorie di legacy system:
- Low quality, low business value: sono sistemi che hanno un basso valore per l'azienda e che sono di bassa qualità. Questi sistemi devono essere sostituiti.
- Low quality, high business value: sono sistemi che hanno un alto valore per l'azienda ma che sono di bassa qualità. Questi sistemi potrebbero essere sostituiti.
- High quality, low business value: sono sistemi che hanno un basso valore per l'azienda ma che sono di alta qualità. Questi sistemi possono essere sostituiti o aggiornati.
- High quality, high business value: sono sistemi che hanno un alto valore per l'azienda e che sono di alta qualità. Questi sistemi potrebbero essere aggiornati ma anche no.

----------------------- Lezione 6 - 10/10/2023 -----------------------

----- VERIFICATION E VALIDATION -----

Verification: "Are we building the product in the right way?", è il processo per capire se il software lo stiamo realizzando nella maniera giusta.
Validation: "Are we building the right product?", è il processo per capire se il software che stiamo realizzando è quello che il cliente vuole.

Il processo V&V deve essere applicato ad ogni stage del nostro progetto. Ha 2 obiettivi:
- La scoperta dei difetti del sistema.
- Dimostrare che il progetto sia usabile e utile in diverse situazioni.

// Teorema della fermata: è impossibile scrivere un algoritmo che riesce a verificare se un software si fermerà o meno.

La confidenza con cui "rispondiamo" alla verifica dei V&V varia in base a:
- Funzioni del software: il livello di confidenza dipende da quanto è critico il software in un organizzazione
- Aspettative degli utenti: cosa si aspetta l'utente dal nostro software
- Condizioni di mercato: cercare di creare un prodotto in poco tempo potrebbe essere più importante rispetto a trovare difetto nei programmi

Come eseguire la V&V:
- Ispezione del software: coincide con l'analisi della rappresentazione del sistema statico per scoprire i problemi (static verification). In questi casi può
                          essere sfruttato un documento tool-based e l'analisi del codice.
- Software testing: coincide con l'esercizio e osservazione del comportamento del prodotto (dynamic verification). Il sistema può essere eseguito con Test
                    data e vengono osservati i comportamenti delle operazioni.

// Il testing può rivelare la presenza di errore ma non la loro assenza.
// Il debug scopre l'errore e il modo in cui risolverlo, il testing rivela solo la presenza.
// Ispezione e testing sono complementari e non opposti, quindi vanno eseguite entrambe.

Tipi di testing:
- Defect testing: test creato per scoprire se il sistema ha difetti. Ha successo quando viene rilevato almeno un difetto nel sistema
- Validaton testing: test creato per capire se il software rispetta i requisiti. Ha successo quando dimostra che il sistema rispetta i requisiti

Il processo di testing:
- Test planning and control: si pianifica il testing e si controlla che venga eseguito correttamente
- Test analysis and design: si analizzano i requisiti e si crea un piano di testing
- Test implementation and execution: si implementa il piano di testing e si esegue
- Evaluating exit criteria and reporting: si valuta se il testing è stato eseguito correttamente e si crea un report
- Test closure activities: si chiude il testing

Non è possibile certificare il funzionamento del software, quindi il testing esaustivo è impossibile.

Test di integrazione (integration testing): è un test che serve per capire se i componenti del sistema funzionano correttamente insieme, qui 
i vari componenti vengono integrati e testati insieme. Esistono due tipi di approcci:
- Top-down integration: sviluppa lo scheletro del sistema e viene popolato con i componenti
- Bottom-up integration: vengono integrate prima le infrastrutture dei componenti e poi vengono aggiunte le funzionalità

Black-box Testing: somministriamo degli input e verifichiamo i vari output senza conoscere com'è stato creato il software.
White-box testing: effettuare i test tramite un software di cui si conosce l'implementazione.

Linee guida per il testing:
- input che coprano il maggior numero di casi possibili
- input che potrebbero far fallire il software

I test di performance sono test che servono per capire se il software rispetta i requisiti di performance. Solitamente si stressa il sistema per vedere come si comporta.
Lo stress testing serve per capire come si comporta il software in condizioni di stress. (viene testato con un carico di lavoro molto alto, anche sopra il limite).

Component testing: è il processo di testare individualmente i componenti del sistema.
I componenti potrebbero essere:
- Oggetti di classi con diversi attributi e metodi
- Componenti compositi formati da interfacce con determinati metodi

Errori legati alle interfacce:
- Interface misuse: l'interfaccia viene usata in modo errato
- Interface misunderstanding: l'interfaccia viene interpretata in modo errato
- Timing errors: l'interfaccia viene usata in modo errato

Linee guida per verificare le interfacce:
- Progettare dei test in modo che i parametri delle funzioni siano fuori dal range
- Progettare dei test con paramentri null
- Progettare dei test con parametri in ordine errato

Test case design: è il processo di progettazione dei test. I test devono essere progettati in modo da coprire il maggior numero di casi possibili.
Requirements-based testing: test che ripropone tutti gli utilizzi fatti da un utente.
Partition testing: partizionare i vari input e sfruttare un input per tutte le classi.
Path testing: test che riesce a controllare almeno una volta tutti i percorsi del nostro algoritmo.
Test automation: è il processo di automatizzazione dei test. I test vengono eseguiti in modo automatico e vengono creati dei report, diminuendo il tempo e i costi. 
                 Per esempio si può usare JUnit per testare il codice Java. ("Controllo della matrice tripla carpiata delle Perri" cit Ricca)

----- CONFIGURATION MANAGMENT -----

Configuration management: è il processo di gestione delle modifiche del software. Il software deve essere aggiornato per rispettare i requisiti e le nuove tecnologie.
Si associa ad un software una procedura di build. 

I cambiamenti arrivano principlamente dagli utenti, sviluppatori, manager, stakeholder, tecnologie, ambiente di sviluppo ecc...
Esistono dei software che aiutano a gestire le modifiche del software (es Git, SVN, CVS ecc...)
Software di controllo del versioni: sono software che aiutano a gestire le modifiche del software (es Git). 
Permettono di:
- Tenere traccia delle modifiche
- Tenere traccia delle versioni

Differenza fra versione, variane e rilascio:
- Versione: è una versione del software distinta dalle altre (con più o meno funzionalità).
- Variante: istanza del sistema identica ma non funzionalmente distinta dalle altre (es versione per Windows e versione per Linux / Git o Git LFS).
- Rilascio: è una versione del software che viene rilasciata al pubblico.

Identificazione delle versioni: procedura che serve a identificare univocamente le versioni del software. Si usa un numero di versione (es 1.0.0) o 
un numero di build. Esistono 3 tecniche:
- Version numbering
- Attribute-based identification
- Change-oriented identification

Gestione dei rilasci: è il processo di gestione dei rilasci del software. I rilasci sono le versioni del software che vengono rilasciate al pubblico. Le nuove 
aggiunte devono essere trovate o dagli utenti o dai cambiamenti dell'hardware.

A volte le release possono anche malviste dagli utenti perchè possono portare a problemi di compatibilità con l'hardware o con altri software, possono essere
tolte funzionalità che piacevano agli utenti ecc...

System release strategy:
- Technical quality release: a volte a causa di bug o di problemi di compatibilità, il software viene rilasciato per risolvere questi problemi.
- Platform changes: a volte il software viene rilasciato per risolvere problemi di compatibilità con l'hardware.
- Customer requested enhancements: a volte il software viene rilasciato per risolvere problemi richiesti dagli utenti.
- Marketing reasons: a volte il software viene rilasciato per motivi di marketing.
- Lehman's fifth law: a volte il software viene rilasciato per rispettare la legge di Lehman, quindi il numero di funzionalità deve essere costante nel tempo.

Ambienti automatici di supporto: sono ambienti che aiutano a gestire le modifiche del software. Per esempio si può usare Jenkins o Maven per gestire le build del software.

----------------------- Lezione 7 - 11/10/2023 -----------------------

----- SOFTWARE PROCESS MANAGMENT (Processo di gestione software) -----

Le attività devono assicurare che il processo sia sviluppato in tempo e in accordo con i requisiti dell'organizzazione.
Ogni progetto ha sempre dei vincoli di budget e di requisiti che vengono stabiliti all'inizio del progetto.

Distinzioni nel processo di gestione software:
- il prodotto è intagibile.
- il prodotto è unicamente flessibile.
- l'ingegneria del software non è riconosciuta come una disciplina ingegneristica.
- il processo di sviluppo non è un processo standardizzato.

Attività tipiche da fare:
- determinare i costi del software
- monitorare e controllare lo sviluppo del software
- assicurare che il software sia sviluppato in tempo e in accordo con i requisiti dell'organizzazione
- selezione del personale 
- presentazione e scrittura di report

Il project planning è l'attività che consuma più tempo. Nel tempo questa attività deve essere ricontrollata per essere sicuri che il progetto sia sviluppato correttamente.
Il project planning è un processo iterativo, quindi la milestone in questi casi è raggiungere le vari iterazioni per mostrarle al cliente.

Come fare la pianificazione:
- introduzione
- organizzazione del progetto
- analisi dei rischi
- requisiti delle risorse hardware e software
- suddivisione del lavoro
- schedulare il progetto
- meccanismo di monitoraggio e comunicazione

Le attività di project planning devono essere organizzate: 
- per produrre outputs tangibili per giudicare un progresso
- avere delle Milestone alla fine di ogni attività
- il risultato finale deve coincidere con ciò che richiesto dal cliente
// il modello a cascata permette di avere delle milestone ben definite 

Rete delle attività: modo per rappresentare le varie task. Ad ogni nodo abbiamo entro quanto tempo deve essere completata la task.
Diagramma di Gantt: è un diagramma che mostra le varie task e il tempo che ci vuole per completarle.
Allocazione del personale sulle task: è un modo per suddivere il lavoro tra il personale. (es Gira)

----- SOFTWARE COST ESTIMATION -----

Domande fondametali da porsi:
- Quanto sforzo è richiesto per completare un'attività?
- Quanto tempo ci vuole per completare un'attività?
- Quanto costa completare un'attività?

Le stime sono fatte per scoprire i costi degli sviluppatori, dei test, dei requisiti e del software. La relazione fra i costi di sviluppo e il prezzo
per il cliente è una relazione molto difficile da capire.

Costo: è il costo per sviluppare il software. Il costo è dato dal costo del personale, del software, dell'hardware ecc...
Prezzo: è il prezzo che il cliente paga per il software. Il prezzo è dato dal costo del software, dal costo del supporto, dal costo del personale ecc...

Fattori di prezzo di un software:
- Market opportunity: è il mercato in cui il software viene venduto. Il prezzo del software dipende dal mercato in cui viene venduto.
- Contruactual terms: è il contratto che viene fatto con il cliente. Il prezzo del software dipende dal contratto che viene fatto con il cliente.
- Cost estimate uncertainty: è l'incertezza che c'è nel calcolare il costo del software.
- Requirements volatility: è la volatilità dei requisiti. Il prezzo del software dipende dai requisiti che il cliente vuole.

Esistono due tipi di misurazioni delle stime:
- Per dimensione: si misura la dimensione del software in modo da capire quanto costa svilupparlo (es numero di linee di codice).
- Per funzionalità: si misura il numero di funzioni del software in modo da capire quanto costa svilupparlo (es numero di funzioni).

Problemi di misurazione:
- Stimare la grandezza della misurazione da sfruttare
- Stimare il numero totale di programmatori
- Stima della produttività dell'appalto e integrazione di tale stima in quella globale

Quindi si possono fare delle analisi basandosi sui punti funzione (Function Point Analysis). I punti funzione sono un modo per misurare la dimensione del software, per
esempio il numero di bottoni, il numero di funzioni ecc... I punti funzione sono un modo per misurare la dimensione del software in modo indipendente dal linguaggio.

LOC (line of code) = AVC * number of function points 

I punti oggetto sono un modo per misurare la dimensione del software in modo indipendente dal linguaggio. Per esempio il numero di classi, il numero di metodi ecc.

Fattori che influenzano la produttività:
- Esperienza del team sul dominio
- Grandezza del progetto
- Supporto tecnologico (es IDE)
- Esperienza del team sul linguaggio

Tecniche per le stime:
- Algorithmic cost modelling: è un modo per stimare il costo del software. Si basa su un modello matematico che prende in input i requisiti e restituisce il costo.
- Expert judgement: è un modo per stimare il costo del software. Si basa sull'esperienza del team.
- Estimation by analogy: è un modo per stimare il costo del software. Si basa su un software simile già sviluppato.
- Parkinson's law: è un modo per stimare il costo del software. Si basa sul tempo che ci vuole per sviluppare il software. ("Il progetto finisce quando la data di scadenza è vicina" )
- Pricing to win: è un modo per stimare il costo del software. Si basa sul prezzo che il cliente vuole pagare per il software.

// Solitamente inizilamente la stima dei costi sarà molto approssimativa, verso la fine invece sarà più accurata.

COCOMO 81 o COCOMO 2: è un modello per stimare il costo del software. Si basa su un modello matematico che prende in input i requisiti e restituisce il costo.

----- MANAGING GROUPS (Gestione dei gruppi) -----

Un'altra task importante è la gestione dei gruppi. I gruppi sono formati da persone che lavorano insieme per raggiungere un obiettivo comune.
Le informazioni per la selezione vengono da:
- informazioni che vengono dai candidati
- informazioni prese da un'intervista, da un test o parlando con i candidati.
- raccomandazioni e commenti con altre persone che sanno o che hanno lavorato con i candidati.

Le persone vengono selezionate in base a:
- conoscenze tecniche
- conoscenze sociali
- conoscenze di problem solving

Un ruolo importante del manager è quello di motivare il team. Motivare qualcuno è un problema complesso perchè ogni persona è diversa e ha bisogno di 
essere motivata in modo diverso. Per esempio si può motivare una persona con un aumento di stipendio, con un premio, training, con un giorno di ferie, soddisfare
i bisogni basici della persona ecc...

Esistono principalmente 3 tipi di persone (Un buon team deve avere tutte e 3 i tipi di persona):
- Task oriented: la persona è motivata a fare un lavoro perchè è interessata a quello che fa.
- Self-oriented: la persona è motivata a fare un lavoro perchè vuole migliorare se stessa (diventare ricca, salire di posizione ecc).
- Interaction-oriented: la persona è motivata a fare un lavoro perchè vuole interagire con altre persone.

Bisogna anche stabilire un Leader del gruppo. Il leader deve essere una persona che ha esperienza e che sa gestire il gruppo e soprattutto un titolo guadagnato.
Chief programming: affiancare persone di esperienza a persone meno esperte in modo da insegnare loro come lavorare.

Le aziende hanno un continuo via vai di persone, quindi è consigliato cercare di far lavorare più persone possibili sullo stesso progetto in modo da non perdere
mai le conoscenze su quella parte di software.

----------------------- Lezione 8 (1^ laboratorio) - 13/10/2023 -----------------------


(guardare appunti laboratorio)


----------------------- Lezione 9 - 17/10/2023 -----------------------

----- ANALISI DEI CASI D'USO FATTA CON LA SCHEDA DEI REQUISITI -----

Questa scheda non ha un modo preciso per essere fatta, infatti può essere divisa in paragrafi o usare anche il modo illustrato nel libro. L'importante è
che ci siano le cose fondametali.

// Il modo migliore per capire quali sono i casi d'uso è impersonificarsi negli stakeholders. 

1) Il nome del caso d'uso solitamente inizia con un verbo (es "Acquistare" nel caso del comprare) 
2) Portata (opzionale): Il sistema che si sta progettando
3) Livello (opzionale): Obiettivo utente o sottofunzione (cioè che si possono usare casi d'uso già descritti per continuarne un altro)
4) Attore primario: Colui che chiede al sistema di fornire i suoi servizi
5)Parti interessati e interessi: coloro che vogliono usufruire del sistema e in che modo (es un cliente che acquista online qualcosa su un 
e-commerce (ovvero il suo obiettivo). Ovviamente ci sono diverse diramazioni possibili (es non trova esattamente ciò che vuole, quindi cerca qualcosa simile).
6) Pre-condizioni (dipende dal caso d'uso, non è obbligatorio che ci sia): Condizioni che si devono verificare prima che il caso d'uso si possa verificare. (NON il login per compare su Amazon)
Le cose ovvie non bisogna metterle (es aver internet per accedere ad un sito) 
7) Garanzia di successo (o Post-condizioni): Descrive come viene alterato lo stato del sistema dopo che il caso d'uso si è svolto.
8) Scenario principale di successo (o Flusso di Base): Uno scenario comune di attraversamento del caso d'uso di successo (infatti si percorre una sola strada). Quindi 
descrivere un insieme di passi (numerati) scritti in modo semplice; dire cosa gli attori dovranno fare. Fornire due scenari di successo e uno di 
insuccesso SOLO se frequente e rilevante.
9) Scenari alternativi (Estensioni): scenari alternativi sia di successo che di fallimento. (es scegliere un metodo di pagamento diverso da quello di default o anche
il fatto che potrebbe cadere internet in momento dello scenario, quindi descrivere cosa succederà dopo il ritorno della connessione)
10) Requisiti speciali (non funzionali): Descrizione requisiti non funzionali.
11) Elenco delle varianti I/O: Varianti dei metodi di I/O e nel formato dei dati ({inserire il tts per le persone senza mani cit Kloz LOL} inserire un stile per 
ritardati oppure qualcosa per i daltonici)
12) Frequenza di ripetizione: frequenza di esecuzione prevista per il casdo d'uso. (es quanti acquisti contemporaneamente vengono fatti)
13) Varie: Altri aspetti (es problemi aperti).

Esempio di caso d'uso completo (Caso d'uso UC1): 
Nome caso d'uso: Elabora vendita (Process Sale)
(Guardare libro, è troppo lungo da scrivere)

// Quando si scrivono i requisiti fare sempre riferimento al binomio "Attore-Obiettivo"

Un caso d'uso è un insieme di scenari che hanno in comune un obiettivo. 
Come identificare i casi d'uso:
1) Scegliere i confini del sistema
2) Identificazione degli attori primari
- Chi avvia o chiude il sistema
- Chi interigisce con i log di sistema
- Chi fornisce dati al sistema
3) Identificazione degli obiettivi degli attori primari
4) Identificazione dei casi d'uso

Test per i casi d'uso:
- Test del capo: Arriva il capo e chiede "cosa avete fatto?", voi rispondete "Il login". Se è felice, il test è superato altrimenti no.
- Test EBP (Elementary Business Process): Se la funzionalità del caso d'uso porta qualche vantaggio all'utilizzatore, il test è superato altrimenti no.
- Test della dimensione: il caso d'uso deve essere LUNGO. Se è corto, il test è fallito. 

Operazioni CRAD (Create, Read, Update, Delete): sono operazioni che solitamente sono nello stesso caso d'uso. (es aggiungere un prodotto al carrello)
UML (Unified Modeling Language): è un linguaggio di modellazione e specifica basato sul paradigma orientato agli oggetti. Serve per descrivere i casi d'uso.


----------------------- Lezione 10 - 18/10/2023 -----------------------

----- DIAGRAMMI DELLE CLASSI -----

Il modello di dominio (o modello concettuale) è un modo per descrivere il dominio del problema attraverso la rappresentazione grafica delle classi di oggetti 
che popolano il nostro domimio. Il modello di dominio deve esssere UNICO per progetto. All'interno non è necessario inserire i vari metodi dato che questo
NON è programmazione. (si usa UML per rappresentare il modello di dominio). ALl'interno troveremo quindi oggetti di dominio o classi concettuali, associazioni tra 
classi concettuali e attributi di classi concettuali. Quindi avremo SOLO nome della classe e attributi (evitare di mettere Database o concetti di implementazione).

// sul libro (Tabella 9.1) è presente un esempio di cosa possiamo inserire nel modello di dominio.

Linee guida:
- per aiutarsi si possono evidenziare possibili classi di oggetti da inserire nel modello di dominio.
- utilizzare nomi esistenti sul territorio
- escludere caratteristiche irrilevanti o fuori portata 
- evitare di inserire cose inutili
- modellare gli oggetti del mondo non reale (es un app di messaggistica)
- usare le classi descrizione (es un menù di una pizzeria in cui aggiungiamo la descrizione della pizza)
    1) inserire una descrizione SOLO se necessaria e indipendentemente dal fatto se sia disponibile o meno.
    2) quando l'eliminazione di istanze degli oggetti che descrivono darebbe luogo ad una perdita di informazioni che è necesasario conservare.
    3) quando si vogliono ridurre le informazioni rindondanti o ripetute.

Quando si va a fare la descrizione del modello di dominio si parla di associazioni e attributi:
- Associazioni: è una relazione fra una o più classi. In UML è la rappresentazione semantica tra due o più classificatori che comporta una connessione fra le rispettive 
                istanze. Importante inserire solo le associazioni necessarie e non tutte quelle che si potrebbero andare a creare.
                (es Facebook. Io e Noemi siamo amici nella vita REALE, quindi si crea un'associazione fra noi due ma non su Facebook. Di conseguenza non si crea 
                un'associazione RILEVANTE per Facebook da inserire nel modello di dominio). Dare nomi alle associazioni in modo da capire cosa rappresentano, devono
                contenere verbi generici e una freccia di direzione di lettura. 
                (es Nome classe - verbo + locuzione - Nome classe : "Il giocatore - è su un - quadrante")

- Attributi: è un valore logico di un oggetto. In UML è una proprietà di un classificatore che descrive un valore che è contenuto in ogni istanza del classificatore.
             Bisogna rispettare un'annotazione per inserirli nel modello di dominio. (es Nome attributo : tipo attributo)

Valore: è un'istanza di un tipo di dato. In UML è un'istanza di un tipo di dato. (es 1, 2, 3, 4, 5 ecc...). I valori sono sempre costanti. I valori non hanno un'anima
e non si ha bisogno di distinguerli e associarli.
Oggetto: è un'istanza di una classe. In UML è un'istanza di un classificatore. Gli oggetti sono sempre variabili.
Questo confronto è molto simile a quando in una diagramma E-R bisogna scegliere se fare una relazione o un'entità.

Linee guida per attributi:
- Ha sezioni separate (es numero di telefono o nome)
- Ci sono operazioni associate ad esso (es un numero di telefono può essere chiamato)
- Ha un valore che può essere calcolato, misurato o derivato (es il prezzo/peso di un prodotto)
- Ha un valore che è un'enumerazione (es il sesso)
- Ha un valore che è un'identificatore, quindi in ID univoco (es il codice fiscale)

Ovviamente NON esiste un solo dominio corretto (un pò come un modello E-R) perchè sono approssimazioni del dominio che si sta tentando ci rappresentare. 

----- DIAGRAMMI DI SEQUENZA DI SISTEMA (o SSD) -----

E' una figura che mostra per particolare scenario di un caso d'uso gli con eventi generati da attori esterni, il loro ordine e gli eventi tra sistemi. All'interno abbiamo 
degli attori che interagiscono con un determinato evento. Qui l'attore avvia un evento e riceverà una risposta da parte del sistema. In questo diagramma bisogna inserire 
il nome dell'attore e per ogni evento un nome ed eventuali attributi utili all'evento. (Figura 10.1 libro)
Inserire un SSD per OGNI scenario principale di caso d'uso e per gli scenari alternativi più frequenti. I nomi delle funzioni devono avere un senso e devono inseriti
in un glossario, dove vengono descritti in modo dettagliato. 

----------------------- Lezione 11 - 24/10/2023 -----------------------

(Esempi sul libro)
Contratto (numero identificativo tipo C02/C03): un contratto è qualcosa nel quale verrà specificato per le operazioni i riferimenti, le pre-condizoni e le post-condizioni.
Nelle pre e post condizioni bisogna mettere che cosa verrà fatto.
Inserire in ordine:
- Nome operazione (nome e paramentri dell'operazione)
- Riferimenti (casi d'uso in cui può verificarsi questa operazione)
- Pre-condizioni
- Post-condizioni, cosa indicare (devono essere fatte in modo dichiarativo, quindi non si deve dire come fare ma cosa fare): 
    1) Creazione o cancellazione di istanza.
    2) Cambiamento del valore di un attributo.
    3) Cambiamento del valore di un'associazione (collegamenti in UML anche).

Come creare i contratti:
1) Identificare le operazioni di sistema dagli SSD.
2) Creare un contratto per le operazioni di sistema più complesse 
3) Descrivere le post-condizioni se creano/cancellano/modificano un attributo, associazione formata o spezzata.

// Operazioni di sistema: operazioni che esegue il nostro sistema a scatola nera (non sappiamo come verrà implementata) (Solitamente il C02 viene fatto su queste).

----- ARCHITETTURA SOFTWARE -----

L'architettura software è la struttura o le strutture del sistema, che comprende gli elementi del software, le proprietà esterne di tali elementi e i 
relativi rapporti. L'architettura software è la struttura del sistema, che comprende gli elementi del software, le proprietà esterne di tali elementi e i.
(L'obiettivo è capire se il modo in cui è strutturato il software è in linea con i requisiti non funzionali)

Diagramma di package (in UML): è un diagramma che mostra le dipendenze fra i vari package. Segue l'idea del modello della macchina a strati, quindi si hanno diversi 
layer (livelli) che si occupano di diverse cose. (UI, Domain, Technical Services ecc...).
Solitamente si cerca di rendere indipendenti i vari layer (non è una regola che bisogna rispettare sempre, ma è consigliato)

Gli strati di un sistema orientato agli oggetti sono divisi in (secondo il pattern MVC):
- Model: è la parte che si occupa della logica del software.
- View: è la parte che si occupa dell'interfaccia grafica.
- Controller: è la parte che si occupa di gestire le richieste dell'utente.

/*
Ordine su come farlo:
1) UI
2) Application (Workflow, App controller)
3) Domain 
4) Business Infrastrucuture (accesso al DB, accesso ad un sistema esterno)
Non identificare risorse esterne. (es COTS o DB).
*/

----- FINE ARGOMENTO ESONERO ----- 

----- DESIGN DI PATTERN ----- 

Design di pattern: sono modelli di progettazione che possono essere riutilizzati per risolvere problemi ricorrenti. Il nome del pattern solitamente deve essere
descrittivo. Descrive il problema, la soluzione e le conseguenze.
Soluzione: è una descrizione di un design generale che risolve il problema. Da una descrizione astratta e indipendente da una concreta implementazione.
Conseguenze: sono le conseguenze positive e negative della soluzione.
Ogni pattern ha un nome ed una classificazione: cosa fa il design di pattern e perchè? Qual è l'intento?
Ha una struttura: come è fatto il design di pattern? Quali sono le classi e gli oggetti che lo compongono?
Ha dei partecipanti: quali sono le classi e gli oggetti che compongono il design di pattern? Quali sono le loro responsabilità?

I pattern vengono classificati in base al:
- Purpose: scopo del pattern
    - Creational: pattern che si occupano della creazione di oggetti
    - Structural: pattern che si occupano della composizione di classi e oggetti (es usare strutture ad albero)
    - Behavioral: pattern che si occupano della comunicazione fra classi e oggetti (es Observer)
- Scope: ambito del pattern
    - Class: pattern che si applicano a classi e sottoclassi (si basano fortemente sull'ereditarietà)
    - Object: pattern che si applicano a oggetti
    - Participants: partecipanti del pattern

Come selezionare un DP:
- Considerare come il pattern risolve il problema
- Vedere le loro correlazioni
- Considerare cosa può variare nel progetto
- Considerare le conseguenze del pattern

----------------------- Lezione 12 - 25/10/2023 -----------------------

----- PATTERN DI CREAZIONE -----

- Factory Method(FM)
- Abstract Factory (AF)
- Builder (BU)
- Prototype (PR)
- Singleton (SI)

----- FACTORY METHOD -----

Factory Method (FM, Metodo di fabbrica): Definisce un interfaccia per creare un oggetto, ma lasciare alle sottoclassi la decisione su quale classe istanziare, conosciuto
come costruttore virtuale. Immagina di avere un framework applicativo per aprire diversi documenti. L'app non può sapere in anticipo cosa deve creare, quindi si ridefinisce
un metodo "CreaDocumento" che cambierà il comportamento in base a quale documento si vuole aprire. (es Word, Excel ecc...). Il metodo "CreaDocumento" è il Factory Method.

Quando usare FM:
- quando la classe non può anticipare in che modo va creato l'oggetto.
- quando le classi delegano la responsabilità di creazione alle sottoclassi, e si vuole localizzare quale sottoclasse è reponsabile della creazione.

Conseguenze di FM:
- si elimina la necessità di legare il codice specifico dell'applicazione alla classe concreta (quindi in caso di aggiornamenti bisogna crea solo una nuova sottoclasse).
- i clienti devono sapere che per instanziare una classe c'è bisogno di un creatore (Factory Method).
- da un aggancio per le sottoclassi. Creare un oggetto dentro un classe con FM è più flessibile che crearlo dentro un costruttore.

Implementazione FM:
- creare una classe astratta che non da nessuna implementazione di default
- creare una classe che da un Implementazione di default
- FM parametrizzato 

----- SINGLETON -----

(c'è anche bisogno? xd)

Bisogna usarlo quando abbiamo bisogno di una sola istanza per tutti il progetto.
Come implementarlo:
- costruttore privato.
- creare l'oggetto statico e privato nella classe.
- creare un metodo statico pubblico per ritornare l'oggetto creato.


----------------------- Lezione 12 - 31/10/2023 -----------------------

----- ABSTRACT FACTORY -----

Look-and-feel: è uno standard che definisce l'aspetto e il comportamento di un prodotto software. (es Windows, Mac ecc...)
Obiettivo: fornire un'interfaccia per creare famiglie di oggetti correlati o dipendenti senza specificare le classi concrete.
Differenti look-and-feels quindi definiscono differenti componenti grafici. (es Windows usa un tipo di bottone diverso da Mac)
La differenza fra AF e FM è che l'Abstract Factory crea famiglie di oggetti correlati o dipendenti mentre il Factory Method crea un solo oggetto.
Inoltre nella AF si occupa la fabbrica di creare l'oggetto mentre nella FM si occupa la sottoclasse di creare l'oggetto.

Quando usare AF:
- un sistema deve essere indipendente da come i suoi prodotti sono creati, composti e rappresentati.
- un sistema deve essere configurato con una famiglia di prodotti.
- una famiglia di prodotti correlati è progettata per essere usata insieme e si vuole imporre questa vincolo.
- bisogna implementare una libreria di classi e si vuole rendere disponibile la sua interfaccia di livello superiore senza rivelare la sua implementazione.

Conseguenze di AF:
- Isola le classi concrete. Il codice del nostro progetto non farà riferimento al costruttore specifico per creare un oggetto.
- Impone un vincolo di coerenza. Siccome non si usa il costruttore, in automatico crea oggetti delle stessa famiglia.
- E' molto difficile aggiungere un nuovo prodotto. Se aggiungiamo un nuovo prodotto dobbiamo aggiungere un altro metodo fabbrica a tutte le sottoclassi presenti.

Come implementrare AF:
- Usare il pattern Singleton per garantire che durante l'esecuzione ci sia solo un oggetto di un determinato tipo. 
- Dichiarare solo l'interfaccia per creare prodotti. Le sottoclassi si occuperanno di implementare i metodi.
- Definire un metodo fabbrica per ogni prodotto da creare.

Oppure:
- Creare un metodo parametrico con il tipo di oggetto da creare che avrà un switch case per creare l'oggetto giusto.


----------------------- Lezione 13 - 14/11/2023 -----------------------

----- PROTOTYPE (PR) -----
Specifica il tipo di oggetto da creare usando un'istanza prototipo e quindi il nuovo oggetto viene creato clonando questo prototipo.

Esempio costruttore di copia C++:
class MyClass {
    int data;

public:
    // Costruttore normale
    MyClass(int value) : data(value) { }

    // Costruttore di copia
    MyClass(const MyClass& source) {
        data = source.data;
    }
};

in Java:
public class MyClass implements Cloneable {
    int data;

    public MyClass(int data) {
        this.data = data;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
Oppure usare Seralizable, in modo da poter scriverli su file e poi rileggerli quando si vuole.

Quando usare PR:
- quando le classi da istanziare sono specificate a runtime.
- per evitare di usare AF dato che potrebbe diventare molto molto grande.

Come sfruttarlo:
1) Creare un riferimento al nostro prototipo.
2) Quando dobbiamo clonare l'oggetto faremo riferimento al prototipo.

Conseguenze PR:
- Aggiungere e rimuovere prodotti a runtime.
- Ridurre la necessità di creare altre classi rispetto ad altri pattern (es AF) 
- Si perde la coerenza delle famiglie di oggetti.
- In java non esiste un costruttore di copia.

In Java, la Reflection è un potente strumento che permette di ispezionare o modificare il comportamento di classi, interfacce, campi 
e metodi a runtime. 
Il PR può essere usato per l'AF.

----- BUILDER (BU) -----
Questo pattern ha l'obiettivo di separare la costruzione di oggetti complessi dalla sua rappresentazione.
Non è necessario usare classi astratte per i prodotti perchè spesso non sono oggetti.

Quando usare BU:
- Ogni qual volta l'algoritmo di costruzione deve essere indipendente da ciò che andiamo a creare
- Quando il processo di creazione deve rappresentare più oggetti.

Esempio in Java:
public interface Builder {
    void parseText();
    void buildPartB();
    void buildPartC();
}

// Metodi di costruttori delle parti (Specifico builder)
public class ConcreteBuilder implements Builder {
    @Override 
    public void parseText() {
        // Implementazione del metodo
    }

    @Override
    public void buildPartB() {
        // Implementazione del metodo
    }

    @Override
    public void buildPartC() {
        // Implementazione del metodo
    }
}

public class Director {
    private Builder builder;

    public Director(Builder builder) {
        this.builder = builder;
    }

    public void construct() {
        builder.buildPartA();
        builder.buildPartB();
        builder.buildPartC();
    }
}

public class Main {
    public static void main(String[] args) {
        Builder builder = new ConcreteBuilder();
        Director director = new Director(builder);
        director.construct();
    }
}

Conseguenze BU:
- Isola il codice per la costruzione e la rappresentazione
- Il cliente non sa nulla sulla struttura interna del prodotto.
- Il prodotto viene costruito step by step dal director.

Il director è una componente che controlla il processo di costruzione di un oggetto. Il Director utilizza un oggetto Builder per 
costruire un oggetto complesso, passo dopo passo. Non è a conoscenza dei dettagli concreti delle classi dei Builder e interagisce 
solo con l'interfaccia Builder. Questo permette di cambiare o riutilizzare il codice di costruzione dell'oggetto senza 
cambiare il codice del Director.
Nell'esempio in un editor di testo in input si potrebbe usare l'AF, in output il BU. (Domanda che potrebbe fare all'orale)


----------------------- Lezione 14 - 15/11/2023 -----------------------

----- PATTERN STRUTTURALI -----

- Adapter (AD)
- Proxy
- Bridge
- Decorator
- Composite
- Flyweight
- Facade

----- Adapter (AD) ----- 
Questo pattern (conosciuto anche come Wrapper) ha l'obiettivo di convertire l'interfaccia di una classe in un'altra interfaccia che i clienti si aspettano. Quindi permettono 
alle classi di lavorare insieme anche quando non dovrebbero a causa di incompatibilità.

Quando usare AD: quando si vuole usare una classe esistente ma la sua interfaccia non è compatibile con quella che si vuole usare.

Esempio:
// Interfaccia esistente
interface OldInterface {
    void oldMethod();
}

// Classe esistente che implementa l'interfaccia esistente
class OldClass implements OldInterface {
    public void oldMethod() {
        System.out.println("Old Method");
    }
}

// Nuova interfaccia che i clienti si aspettano
interface NewInterface {
    void newMethod();
}

// Adapter che implementa la nuova interfaccia e utilizza l'interfaccia esistente
class Adapter implements NewInterface {
    private OldInterface oldObject;

    public Adapter(OldInterface oldObject) {
        this.oldObject = oldObject;
    }

    public void newMethod() {
        oldObject.oldMethod();
    }
}

// Classe cliente che utilizza la nuova interfaccia
public class Client {
    public static void main(String[] args) {
        OldInterface oldObject = new OldClass();
        NewInterface adapter = new Adapter(oldObject);
        adapter.newMethod();
    }
}


----- BRIDGE (BR) -----
Questo pattern serve a collegare un'astrazione alla sua implementazione.

Quando usare BR:
- quando un'astrazione può avere diverse implementazioni (es Swing di java che varia in base al siste,a operativo).
- quando non voglio avere un collegamento permanente fra l'astrazione e la sua implementazione.
- l'implementazione verrà selezionata a tempo di esecuzione.
- vogliamo nascondere l'implementazione di un'astrazione ai clienti (esempio i DLL in windows).

Conseguenze BR:
- un'implementazione non è collegata permanentemente ad un'interfaccia
- l'implementazione di un'astrazione può essere configurata/cambiata a tempo di esecuzione.

Il BR può essere usato insieme all'AF. Si può usare l'AF per la creazione delle varie implementazioni, ma non per l'astrazione vera e propria.
Per esempio se abbiamo l'astrazione di Windows collegata tramite BR alla WindowsImpl, possiamo usare l'AF per la creazione di prodotti diversi
della stessa famiglia WindowsImpl. Quindi avremo una fabbrica di WindowsImpl che crea bottoni, scrollbar ecc (ovvero i prodotti concreti) in 
base a cosa noi scegliamo di creare (WindowsImplIos, WindowsImplAndroid ecc).

Esempio:
// Implementor
interface Implementor {
    void operationImpl();
}

// Concrete Implementors
class ConcreteImplementorA implements Implementor {
    public void operationImpl() {
        System.out.println("Concrete Implementor A");
    }
}

class ConcreteImplementorB implements Implementor {
    public void operationImpl() {
        System.out.println("Concrete Implementor B");
    }
}

// Abstraction
abstract class Abstraction {
    protected Implementor implementor;

    public Abstraction(Implementor implementor) {
        this.implementor = implementor;
    }

    public abstract void operation();
}

// Refined Abstraction
class RefinedAbstraction extends Abstraction {
    public RefinedAbstraction(Implementor implementor) {
        super(implementor);
    }

    public void operation() {
        implementor.operationImpl();
    }
}

// Client
public class Client {
    public static void main(String[] args) {
        Implementor implementorA = new ConcreteImplementorA();
        Abstraction abstractionA = new RefinedAbstraction(implementorA);
        abstractionA.operation();

        Implementor implementorB = new ConcreteImplementorB();
        Abstraction abstractionB = new RefinedAbstraction(implementorB);
        abstractionB.operation();
    }
}


----- FACADE (FA) -----
Questo pattern ha l'obiettivo di fornire un'interfaccia unificata ad un serie di interfacce in un sottosistema. Fornisce un interfaccia di alto 
livello che facilita l'utilizzo del sottosistema.

Quando usare FA:
- quando voglia nascondere al cliente le vere implementazioni, facilitando anche eventuali modifiche.
- quando vogliamo offrire un'interfaccia semplice per un sottosistema complesso, garantendo una buona UI e UX.

Conseguenze FA:
- Isola i clienti dal sottosistema, riducendo il numero di oggetti con cui l'utente può operare.
- Promuove il disaccoppiamento fra sottosistema e clienti.
- Riduce la possibilità di avere cicli di dipendenze di compilazione.

FA può essere collegato all'AF, SI e Mediator.

Esempio:
// Classi del sottosistema
class SubsystemClass1 {
    public void method1() {
        System.out.println("SubsystemClass1 method1");
    }
}

class SubsystemClass2 {
    public void method2() {
        System.out.println("SubsystemClass2 method2");
    }
}

// Facade
class Facade {
    private SubsystemClass1 subsystem1;
    private SubsystemClass2 subsystem2;

    public Facade() {
        subsystem1 = new SubsystemClass1();
        subsystem2 = new SubsystemClass2();
    }

    public void operation() {
        subsystem1.method1();
        subsystem2.method2();
    }
}

// Client
public class Client {
    public static void main(String[] args) {
        Facade facade = new Facade();
        facade.operation();
    }
}

----------------------- Lezione 15 - 21/11/2023 -----------------------

----- COMPOSITE (CO) -----
Questo pattern ha l'obiettivo di comporre oggetti in strutture ad albero per rappresentare gerarchie parte-tutto. Permette ai clienti di trattare
in modo uniforme oggeti che sono composizione di altri oggetti. Quindi questo design massimizza i comportamenti dell'interfaccia, rendendo trasparente
l'utilizzo di ogni componente.

Quando usare CO:
- quando si vuole rappresentare gerarchie parte-tutto di oggetti.
- quando si vuole che i clienti trattino in modo uniforme oggetti singoli e composizioni di oggetti.

Conseguenze CO:
- il composito rende più semplice aggiungere nuovi oggetti
- nel momento in cui si usa questo pattern bisogna sapere quali sono le foglie e quali sono i composite object
- foglie e composite hanno la stessa interfaccia, quindi la parte client è facile da gestire
- si possono condividere i vari componenti
- l'ordine dei figli varia in base al composite che usiamo
- può migliorare le performance (es usare il BACKTRACKING)
- dobbiamo noi (non in java :P) occuparci della distruzione degli oggetti.

Esempio:
// Component
interface Graphic {
    void draw();
}

// Leaf
class Circle implements Graphic {
    public void draw() {
        System.out.println("Draw Circle");
    }
}

// Composite
class GraphicComposite implements Graphic {
    private List<Graphic> graphics = new ArrayList<>();

    public void addGraphic(Graphic graphic) {
        graphics.add(graphic);
    }

    public void draw() {
        for (Graphic graphic : graphics) {
            graphic.draw();
        }
    }
}

// Client
public class Client {
    public static void main(String[] args) {
        Circle circle1 = new Circle();
        Circle circle2 = new Circle();

        GraphicComposite graphicComposite = new GraphicComposite();
        graphicComposite.addGraphic(circle1);
        graphicComposite.addGraphic(circle2);

        graphicComposite.draw();
    }
}

----- FLYWEIGHT (FL) -----

Sfrutta la condivisione per supportare la gestione di un grande numero di oggetti in modo efficiente.

Quando usare FL:
- quando si vuole usare un gran numero di oggetti
- quando i costi di archiviazione sono alti
- quando la maggior parte dello stato di un oggetto può essere reso esterno
- quando molti gruppi di oggetti possono essere sostituiti da pochi oggetti condivisi
- quando l'applicazione non dipende dallo stato dell'oggetto

Conseguenze FL:
-  più flyweights sono condivisi, più sarà efficiente

Esempio:
// Flyweight interface
interface Flyweight {
    void operation();
}

// Concrete Flyweight
class ConcreteFlyweight implements Flyweight {
    private String intrinsicState;

    public ConcreteFlyweight(String intrinsicState) {
        this.intrinsicState = intrinsicState;
    }

    public void operation() {
        System.out.println("Operation with state: " + intrinsicState);
    }
}

// Flyweight Factory
class FlyweightFactory {
    private Map<String, Flyweight> flyweights = new HashMap<>();

    public Flyweight getFlyweight(String key) {
        if (!flyweights.containsKey(key)) {
            flyweights.put(key, new ConcreteFlyweight(key));
        }
        return flyweightgs.get(key);
    }
}

// Client
public class Client {
    public static void main(String[] args) {
        FlyweightFactory factory = new FlyweightFactory();

        Flyweight flyweight1 = factory.getFlyweight("A");
        flyweight1.operation();

        Flyweight flyweight2 = factory.getFlyweight("A");
        flyweight2.operation();

        System.out.println(flyweight1 == flyweight2); // Should print 'true'
    }
}

----- DECORATOR -----
Consente di collegare nuovi comportamenti agli oggetti posizionando questi oggetti all'interno di oggetti wrapper speciali che contengono i comportamenti. Questo 
può essere più flessibile dell'ereditarietà perché le funzionalità possono essere aggiunte e rimosse a runtime.

Quando usare DE:
- quando si vuole aggiungere responsabilità a singoli oggetti in modo dinamico e trasparente
- quando non si vuole usare l'ereditarietà per aggiungere responsabilità
- quando si vuole creare oggetti che condividano un'implementazione

Ecco come funziona:
1) Si definisce un'interfaccia o una classe astratta ('Component') per l'oggetto che si desidera decorare.
2) Si crea una classe concreta che implementa o estende 'Component'.
3) Si crea una classe astratta Decorator che implementa anche 'Component' e ha un campo di riferimento a un 'Component'. Questo campo viene 
inizializzato tramite il costruttore.
4) Si creano classi Decorator concrete che estendono la classe astratta Decorator e aggiungono nuovi comportamenti nel metodo 'operation'.
In questo modo, si può avvolgere un oggetto con uno o più decoratori per aggiungere funzionalità in modo dinamico.

Esempio:
// Component
interface Component {
    void operation();
}

// Concrete Component
class ConcreteComponent implements Component {
    public void operation() {
        System.out.println("Concrete Component");
    }
}

// Decorator
class Decorator implements Component {
    private Component component;

    public Decorator(Component component) {
        this.component = component;
    }

    public void operation() {
        component.operation();
    }
}

// Concrete Decorator
class ConcreteDecorator extends Decorator {
    public ConcreteDecorator(Component component) {
        super(component);
    }

    public void operation() {
        super.operation();
        System.out.println("Concrete Decorator");
    }
}

// Client
public class Client {
    public static void main(String[] args) {
        Component component = new ConcreteComponent();
        component.operation();

        Component decorator = new ConcreteDecorator(component);
        decorator.operation();
    }
}

----------------------- Lezione 16 - 22/11/2023 -----------------------

----- PROXY (PR) -----
Questo pattern ha l'obiettivo di fornire un surrogato (sostituto) o un segnaposto per un altro oggetto per controllare l'accesso a questo 
oggetto.
Un proxy è una classe che ha la stessa interfaccia dell'oggetto reale. Il proxy NON deve conoscere il tipo dell'oggetto reale. Bisogna creare un proxy per ogni
oggetto vero. Il metodo equals() può essere utile per capire l'identità dell'oggetto.

Esistono 3 tipi di proxy:
- Proxy virtuale: aumenta la velocità di avvio dell'applicazione. Infatti per l'avvio sfrutterà i surrogati; nel momento in cui invece serve 
  la vera risorsa, il proxy creerà l'oggetto richiesto.
- Proxy remoto: è un tipo di proxy che fornisce una rappresentazione locale di un oggetto che risiede in un diverso spazio di indirizzamento, tipicamente un server 
  remoto. In altre parole, un Proxy Remoto può essere visto come un surrogato locale di un oggetto che si trova in un'altra area di rete.
  Il ProxyRemoto è responsabile per la comunicazione tra il client e l'oggetto remoto. Questa comunicazione può includere la gestione della connessione di rete, 
  l'invio di richieste al server remoto, la ricezione delle risposte, ecc. Un esempio comune di Proxy Remoto è un oggetto stub in un sistema di chiamata di procedura 
  remota (RPC). Lo stub funge da Proxy Remoto per l'oggetto remoto. Il client interagisce con lo stub come se fosse l'oggetto reale, ma in realtà lo stub gestisce la comunicazione di rete con l'oggetto remoto.
- Proxy di protezione: generalizza l'interfaccia di metodi. Molto utilizzato per la gestione dell'autenticazione. Si crea un'interfaccia 
  uguale per tutti (es utente, amministratore) e poi se si è amministratore si crea l'oggetto vero, se si è utente si crea il proxy. Infine con
  try-catch controlliamo se è un proxy o meno. Quando il proxy chiamerà i metodi che non possono essere chiamati, allora darà un expection.

Esempio: 
// Interfaccia comune per RealObject e Proxy
interface CommonInterface {
    void operation();
}

// RealObject
class RealObject implements CommonInterface {
    public void operation() {
        System.out.println("RealObject operation");
    }
}

// Proxy
class Proxy implements CommonInterface {
    private RealObject realObject;

    public void operation() {
        if (realObject == null) {
            realObject = new RealObject();
        }
        realObject.operation();
    }
}

// Client
public class Client {
    public static void main(String[] args) {
        CommonInterface proxy = new Proxy();
        proxy.operation();
    }
}

----- BEHAVIORAL PATTERN -----

----- TEMPLATE METHOD (TM) -----
Definisce lo scheletro di un algoritmo in un'operazione, deferendo alcuni passi alle sue sottoclassi. Fa in modo che le sottoclassi ridefiniscono alcuni passi
dell'algoritmo senza cambiare la struttura, quindi generalizziamo una parte dell'algoritmo.

Esempio:
// Classe astratta con il metodo template
abstract class AbstractClass {
    public void templateMethod() {
        operation1();
        operation2();
    }

    protected abstract void operation1();
    protected abstract void operation2();
}

// Classe concreta che implementa le operazioni
class ConcreteClass extends AbstractClass {
    protected void operation1() {
        System.out.println("ConcreteClass operation1");
    }

    protected void operation2() {
        System.out.println("ConcreteClass operation2");
    }
}

// Client
public class Client {
    public static void main(String[] args) {
        AbstractClass concreteClass = new ConcreteClass();
        concreteClass.templateMethod();
    }
}

----- INTERPRETER (IN) -----
E' un pattern di progettazione comportamentale che viene utilizzato per interpretare le lingue. Questo pattern definisce come valutare le espressioni in una lingua. 
L'idea di base è avere una classe per ogni simbolo (terminale o non terminale) in una lingua specifica. Il pattern Interpreter implica la costruzione di un interprete 
per una grammatica definita. Ogni regola della grammatica è una classe separata. Per interpretare una frase della lingua, l'interprete utilizza una struttura ad 
albero di tali classi. (Composite pattern)
L'interpreter è il risultato rappresentato tramite oggetti del parser.

Esempio:
// Interfaccia dell'interprete
interface Interpreter {
    int interpret();
}

// Interprete concreto
class Number implements Interpreter {
    private int number;

    public Number(int number) {
        this.number = number;
    }

    public int interpret() {
        return number;
    }
}

// Client
public class Client {
    public static void main(String[] args) {
        Interpreter number = new Number(5);
        System.out.println(number.interpret());
    }
}

----------------------- Lezione 17 - 24/11/2023 -----------------------

----- OBSERVER (OB) -----
E' un pattern che definisce una dipendenza uno a molti fra gli oggetti in modo che quando un oggetto cambia stato, tutte le dipendenze 
vengono notificate e aggiornate automaticamente (es Observer di Java o Angular). Aiuta quindi a mantenere la consistenza fra dati che vengono
condivise fra più classi, cercando di mantenere un legame basso fra le classi. Supporta le comunicazioni broadcast; bisogna fare sempre
molta attenzione a chi mandiamo gli aggiornamenti. Si può usare una hashtable per mappare i subject e gli observer. Nel momento in cui
le informazioni sono molto complesse da gestire, è consigliato usare un ChangeManager che gestirà le dipendenze fra subject e observers, quindi
fa da mediatore.

Polling: è un metodo per controllare lo stato di un dispositivo, un servizio o una risorsa. Consiste nel fare richieste periodiche (o "sondaggi")
per verificare se ci sono nuovi dati disponibili o se lo stato di una risorsa è cambiato.

Subject (publisher): conosce i suoi observers. Un subject può avere più subscriber 
Observer (subscriber): avrà un riferimento al subject cocreto e implementa l'interfaccia observer.

Quando usare OB:
- quando un cambiamento in un oggetto richiede un cambiamento in altri oggetti e non si sa quanti oggetti devono essere cambiati.
- quando un oggetto deve essere in grado di notificare altri oggetti senza fare ipotesi su chi sono questi oggetti.

Esistono due tipi di model:
- push model: il subject manda agli observers informazioni dettagliate sui cambiamenti, anche se non richiesto.
- pull model: il subject manda notifiche agli observers ma in modo non dettagliato; gli observer possono richiedere i dettagli.

Esempio:
// Interfaccia Observer
interface Observer {
    void update();
}

// Interfaccia Observable
interface Observable {
    void addObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}

// Concrete Observable
class ConcreteObservable implements Observable {
    private List<Observer> observers = new ArrayList<>();

    public void addObserver(Observer observer) {
        observers.add(observer);
    }

    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update();
        }
    }
}

// Concrete Observer
class ConcreteObserver implements Observer {
    public void update() {
        System.out.println("ConcreteObserver update");
    }
}

// Client
public class Client {
    public static void main(String[] args) {
        Observable observable = new ConcreteObservable();
        Observer observer = new ConcreteObserver();
        observable.addObserver(observer);
        observable.notifyObservers();
    }
}

----------------------- Lezione 18 - 28/11/2023 -----------------------

----- MEDIATOR (ME) -----
Definisce un oggetto che incapsula come un set di oggetti interagisce. Quindi più oggetti collaborano con lo stesso obiettivo e sono interdipendeti.
Quindi più oggetti parlano verso il mediatore che agirà di conseguenza sugli oggeti collaboratori.

Quando usare ME: 
- quando più oggetti devono comunicare in modo definito ma complesso

Conseguenze: 
- si minimizza il bisogno di creare classi
- semplifica il protocollo di comunicazione

Il ME non interessa fare scambio di messaggi rispetto all'OB. Il ME vuole solo notificare un cambiamento.

Esempio:
// Mediator interface
public interface Mediator {
    void send(String message, Colleague colleague);
}

// Concrete Mediator
public class ConcreteMediator implements Mediator {
    private Colleague colleague1;
    private Colleague colleague2;

    public void setColleague1(Colleague colleague) {
        this.colleague1 = colleague;
    }

    public void setColleague2(Colleague colleague) {
        this.colleague2 = colleague;
    }

    @Override
    public void send(String message, Colleague colleague) {
        if (colleague == colleague1) {
            colleague2.notify(message);
        } else {
            colleague1.notify(message);
        }
    }
}

// Colleague interface
public interface Colleague {
    void send(String message);
    void notify(String message);
}

// Concrete Colleague
public class ConcreteColleague1 implements Colleague {
    private Mediator mediator;

    public ConcreteColleague1(Mediator mediator) {
        this.mediator = mediator;
    }

    @Override
    public void send(String message) {
        mediator.send(message, this);
    }

    @Override
    public void notify(String message) {
        System.out.println("Colleague1 riceve il messaggio: " + message);
    }
}

public class ConcreteColleague2 implements Colleague {
    private Mediator mediator;

    public ConcreteColleague2(Mediator mediator) {
        this.mediator = mediator;
    }

    @Override
    public void send(String message) {
        mediator.send(message, this);
    }

    @Override
    public void notify(String message) {
        System.out.println("Colleague2 riceve il messaggio: " + message);
    }
}

// Client
public class Client {
    public static void main(String[] args) {
        ConcreteMediator mediator = new ConcreteMediator();

        ConcreteColleague1 colleague1 = new ConcreteColleague1(mediator);
        ConcreteColleague2 colleague2 = new ConcreteColleague2(mediator);

        mediator.setColleague1(colleague1);
        mediator.setColleague2(colleague2);

        colleague1.send("Ciao, come stai?");
        colleague2.send("Bene, grazie!");
    }
}

----- CHAIN OF RESPONSABILITY (CoR) -----

Serve a gestire delle richieste tra più oggetti. Un oggetto riceve la richiesta, se non la può gestire la passa all'oggetto successivo.
Un esempio naturale di questo pattern è il try catch. 

Quando usare CoR:
- quando più di un oggetto potrebbe dover gestire una richiesta e non si conosce il gestore a priori.

Conseguenze CoR:
- riduce l'accoppiamento 
- maggiore flessibilità nella'assegnamento della responsabilità

Esempio:
// Step 1: Creare l'interfaccia Handler
public interface Handler {
    void setNext(Handler handler);
    void handleRequest(String request);
}

// Step 2: Creare le classi ConcreteHandler che implementano l'interfaccia Handler
public class ConcreteHandler1 implements Handler {
    private Handler next;

    @Override
    public void setNext(Handler handler) {
        this.next = handler;
    }

    @Override
    public void handleRequest(String request) {
        if ("Richiesta1".equals(request)) {
            System.out.println("ConcreteHandler1 ha gestito la richiesta");
        } else if (next != null) {
            next.handleRequest(request);
        }
    }
}

public class ConcreteHandler2 implements Handler {
    private Handler next;

    @Override
    public void setNext(Handler handler) {
        this.next = handler;
    }

    @Override
    public void handleRequest(String request) {
        if ("Richiesta2".equals(request)) {
            System.out.println("ConcreteHandler2 ha gestito la richiesta");
        } else if (next != null) {
            next.handleRequest(request);
        }
    }
}

// Step 3: Utilizzare il pattern Chain of Responsibility
public class Client {
    public static void main(String[] args) {
        Handler handler1 = new ConcreteHandler1();
        Handler handler2 = new ConcreteHandler2();

        handler1.setNext(handler2);

        handler1.handleRequest("Richiesta1");
        handler1.handleRequest("Richiesta2");
    }
}

----- MEMENTO (MMT) -----

Serve a salvare lo stato di un oggetto in modo da poterlo ripristinare in un secondo momento. Il Memento è un oggetto che incapsula lo stato di 
un altro oggetto.

Quando usare MMT:
- quando bisogna ripristinare in un secondo momento lo stato di un oggetto

Conseguenze MMT:
- semplifichiamo l'interfaccia dell'origine 
- utilizzare il memento può essere costoso
- fare attenzione ai meccanismi di isterisi (es batteria che nel tempo si degrada con le ricariche)

In C++ MMT è supportato molto grazie al friend.

Esempio:
// Step 1: Creare la classe Memento
public class Memento {
    private String state;

    public Memento(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }
}

// Step 2: Creare la classe Originator
public class Originator {
    private String state;

    public void setState(String state) {
        this.state = state;
    }

    public Memento saveStateToMemento() {
        return new Memento(state);
    }

    public void getStateFromMemento(Memento memento) {
        state = memento.getState();
    }
}

// Step 3: Creare la classe Caretaker
public class Caretaker {
    private List<Memento> mementoList = new ArrayList<Memento>();

    public void add(Memento state) {
        mementoList.add(state);
    }

    public Memento get(int index) {
        return mementoList.get(index);
    }
}

// Step 4: Utilizzare il pattern Memento
public class Client {
    public static void main(String[] args) {
        Originator originator = new Originator();
        Caretaker caretaker = new Caretaker();

        originator.setState("Stato1");
        originator.setState("Stato2");
        caretaker.add(originator.saveStateToMemento());

        originator.setState("Stato3");
        caretaker.add(originator.saveStateToMemento());

        originator.setState("Stato4");
        System.out.println("Stato attuale: " + originator.getState());

        originator.getStateFromMemento(caretaker.get(0));
        System.out.println("Primo stato salvato: " + originator.getState());
        originator.getStateFromMemento(caretaker.get(1));
        System.out.println("Secondo stato salva<to: " + originator.getState());
    }
}

----- STATE (ST) -----

Serve a cambiare il comportamento di un oggetto in base al suo stato interno. Quindi cambia il comportamento in base allo stato interno.

Quando usare ST:
- il comportamento di un oggetto dipende dal suo stato e deve cambiare il suo comportamento a tempo di esecuzione
- operazioni condizionali basate sullo stato
- controllare lo stato di un oggetto per determinare l'esecuzione del codice
- implementazione di una funzionalità che consente all'utente di annullare le azioni precedenti

Conseguenze ST:
- rende le transizioni esplicite
- gli oggetti stato possono essere condivisi
- il pattern può essere usato per implementare un automa a stati finiti

Esempio:
// Step 1: Creare l'interfaccia State
public interface State {
    void doAction(Context context);
}

// Step 2: Creare le classi ConcreteState
public class StartState implements State {
    public void doAction(Context context) {
        System.out.println("Start State");
        context.setState(this);
    }

    public String toString() {
        return "Start State";
    }
}

public class StopState implements State {
    public void doAction(Context context) {
        System.out.println("Stop State");
        context.setState(this);
    }

    public String toString() {
        return "Stop State";
    }
}

// Step 3: Creare la classe Context
public class Context {
    private State state;

    public void setState(State state) {
        this.state = state;
    }

    public State getState() {
        return state;
    }
}

// Step 4: Utilizzare il pattern State
public class Client {
    public static void main(String[] args) {
        Context context = new Context();

        StartState startState = new StartState();
        startState.doAction(context);
        System.out.println(context.getState());

        StopState stopState = new StopState();
        stopState.doAction(context);
        System.out.println(context.getState());
    }
}

----- STRATEGY (STG) -----

Il Pattern Strategy è un pattern di progettazione che consente di separare un algoritmo dalle classi che lo utilizzano, e di incapsularli in 
oggetti. Questo permette di cambiare algortimo a tempo di esecuzione.

Quando usare STG:
- quando ci sono diverse implementazioni di un algoritmo
- quando si vuole nascondere l'implementazione di un algoritmo agli utenti
- più classi correlati si differenziano solo nel comportamento (es algoritmi di sorting)

Conseguenze STG:
- definisce una famiglia correlata di algoritmi
- alternativa molto valida al subclassing
- elimina le condizioni if-else o l'uso di switch

Esempio:
// Step 1: Creare l'interfaccia Strategy
public interface Strategy {
    int doOperation(int num1, int num2);
}

// Step 2: Creare le classi ConcreteStrategy
public class OperationAdd implements Strategy {
    public int doOperation(int num1, int num2) {
        return num1 + num2;
    }
}

public class OperationSubtract implements Strategy {
    public int doOperation(int num1, int num2) {
        return num1 - num2;
    }
}

public class OperationMultiply implements Strategy {
    public int doOperation(int num1, int num2) {
        return num1 * num2;
    }
}

// Step 3: Creare la classe Context
public class Context {
    private Strategy strategy;

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }

    public int executeStrategy(int num1, int num2) {
        return strategy.doOperation(num1, num2);
    }
}

// Step 4: Utilizzare il pattern Strategy
public class Client {
    public static void main(String[] args) {
        Context context = new Context(new OperationAdd());
        System.out.println("10 + 5 = " + context.executeStrategy(10, 5));

        context = new Context(new OperationSubtract());
        System.out.println("10 - 5 = " + context.executeStrategy(10, 5));

        context = new Context(new OperationMultiply());
        System.out.println("10 * 5 = " + context.executeStrategy(10, 5));
    }
}

----- COMMAND (CMD) -----

Serve a incapsulare una richiesta in un oggetto, permettendo di parametrizzare i client con richieste diverse, accodare o registrare richieste e 
supportare richieste annullabili.

Quando usare CMD:
- quando si vuole parametrizzare gli oggetti con operazioni
- quando si vogliono accodare le operazioni
- quando si vogliono registrare le operazioni
- quando si vogliono supportare operazioni annullabili
- quando vogliamo fare una collezione di comandi da eseguire tramite un solo comando 

Conseguenze CMD:
- rende più facile creare log e debug
- rende più facile implementare operazioni annullabili
- rende più facile estendere il sistema con nuove operazioni
- rende più difficile gestire l'interfaccia utente

Esempio:
// Step 1: Creare l'interfaccia Command
public interface Command {
    void execute();
}

// Step 2: Creare le classi ConcreteCommand
public class LightOnCommand implements Command {
    private Light light;

    public LightOnCommand(Light light) {
        this.light = light;
    }

    public void execute() {
        light.on();
    }
}

public class LightOffCommand implements Command {
    private Light light;

    public LightOffCommand(Light light) {
        this.light = light;
    }

    public void execute() {
        light.off();
    }
}

// Step 3: Creare la classe Receiver
public class Light {
    public void on() {
        System.out.println("Light is on");
    }

    public void off() {
        System.out.println("Light is off");
    }
}

// Step 4: Creare la classe Invoker
public class RemoteControl {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void pressButton() {
        command.execute();
    }
}

// Step 5: Utilizzare il pattern Command
public class Client {
    public static void main(String[] args) {
        RemoteControl remoteControl = new RemoteControl();

        Light light = new Light();
        Command lightOnCommand = new LightOnCommand(light);
        Command lightOffCommand = new LightOffCommand(light);

        remoteControl.setCommand(lightOnCommand);
        remoteControl.pressButton();

        remoteControl.setCommand(lightOffCommand);
        remoteControl.pressButton();
    }
}

Pattern correlati:
- Compisite
- Memento



----- ITERATOR (ITR) -----